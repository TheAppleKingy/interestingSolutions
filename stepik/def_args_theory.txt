Тема урока: функции с переменным количеством аргументов
Аргументы *args
Аргументы **kwargs
Keyword-only аргументы
Аннотация. Урок посвящен функциям с переменным количеством аргументов.

Переменное количество аргументов
Вспомним функцию print(), которой мы пользуемся почти в каждой задаче.

Приведенный ниже код:

print('a')
print('a', 'b')
print('a', 'b', 'c')
print('a', 'b', 'c', 'd')
выводит:

a
a b
a b c
a b c d
Функция print() принимает столько аргументов, сколько ей передано. Причем функция print() делает полезную работу, даже когда вызывается вообще без аргументов. В этом случае она переносит каретку печати на новую строку.

Было бы здорово научиться писать свои собственные функции, способные принимать переменное количество аргументов. Для этого потребуется специальный, совсем не сложный во всех смыслах, синтаксис.

Рассмотрим определение функции my_func():

def my_func(*args):
    print(type(args))
    print(args)


my_func()
my_func(1, 2, 3)
my_func('a', 'b')
Приведенный выше код выводит:

<class 'tuple'>
()
<class 'tuple'>
(1, 2, 3)
<class 'tuple'>
('a', 'b')
В заголовке функции my_func() указан всего один параметр args, но со звездочкой перед ним. Звездочка в определении функции означает, что переменная (параметр) args получит в виде кортежа все аргументы, переданные в функцию при ее вызове от текущей позиции и до конца.

При описании функции можно использовать только один параметр помеченный звездочкой, причем располагаться он должен в конце списка параметров, иначе последующим параметрам не достанется значений.

Приведенный ниже код:

def my_func(*args, num):
    print(args)
    print(num)
не является рабочим, так как параметр со звездочкой указан раньше позиционного num.

Приведенный ниже код:

def my_func(num, *args):
    print(args)
    print(num)


my_func(17, 'Python', 2, 'C#')
связывает с переменной num значение 
17
17, а с переменной args значение кортежа ('Python', 2, 'C#') и выводит:

('Python', 2, 'C#')
17
Помеченный звездочкой параметр *args нормально переживает и отсутствие аргументов, в то время как позиционные параметры всегда обязательны.

Приведенный ниже код:

my_func(17)
связывает с переменной num значение 
17
17, а с переменной args значение пустого кортежа () и выводит:

()
17
Обратите внимание: функция my_func() принимает несколько аргументов, но как минимум один аргумент должен быть передан обязательно. Этот первый аргумент станет значением переменной num, а остальные аргументы сохранятся в переменной args. Подобным образом можно делать любое количество обязательных аргументов.

Параметр args в определении функции пишется после позиционных параметров перед первым параметром со значением по умолчанию.

Передача аргументов в форме списка и кортежа
Иногда хочется сначала сформировать набор аргументов, а потом передать их функции. Тут поможет оператор распаковки коллекций, который также обозначается звездочкой *.

Вспомним, что встроенная функция sum() принимает на вход коллекцию чисел (список, кортеж, и т.д).

Приведенный ниже код:

sum1 = sum([1, 2, 3, 4])        # считаем сумму чисел в списке
sum2 = sum((10, 20, 30, 40))    # считаем сумму чисел в кортеже

print(sum1, sum2)
выводит:

10 100
Однако функция sum() не может принимать переменное количество аргументов.

Приведенный ниже код:

sum1 = sum(1, 2, 3, 4)        

print(sum1)
приводит к возникновению ошибки:

TypeError: sum expected at most 2 arguments, got 4
Напишем свою версию функции sum(), функцию my_sum(), которая принимает переменное количество аргументов и вычисляет их сумму:

def my_sum(*args):
    return sum(args)    # args - это кортеж
Приведенный ниже код:

print(my_sum())
print(my_sum(1))
print(my_sum(1, 2))
print(my_sum(1, 2, 3))
print(my_sum(1, 2, 3, 4))
выводит:

0
1
3
6
10
Мы также можем вызывать нашу функцию my_sum() , передавая ей списки или кортежи, предварительно распаковав их.

Приведенный ниже код:

print(my_sum(*[1, 2, 3, 4, 5]))   #  распаковка списка
print(my_sum(*(1, 2, 3)))         #  распаковка кортежа
выводит:

15
6
Более того, часть аргументов можно передавать непосредственно и даже коллекции подставлять не только по одной.

Приведенный ниже код:

print(my_sum(1, 2, *[3, 4, 5], *(7, 8, 9), 10))
выводит: 

49
По соглашению, параметр, получающий подобный кортеж значений, принято называть args (от слова arguments). Старайтесь придерживаться этого соглашения.

Получение именованных аргументов в виде словаря
Позиционные аргументы можно получать в виде *args, причём произвольное их количество. Такая возможность существует и для именованных аргументов. Только именованные аргументы получаются в виде словаря, что позволяет сохранить имена аргументов в ключах.

Рассмотрим определение функции my_func():

def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)
Приведенный ниже код:

my_func()
my_func(a=1, b=2)
my_func(name='Timur', job='Teacher')
выводит: 

<class 'dict'>
{}
<class 'dict'>
{'a': 1, 'b': 2}
<class 'dict'>
{'name': 'Timur', 'job': 'Teacher'}
По соглашению параметр, получающий подобный словарь, принято называть kwargs (от словосочетания keyword arguments). Старайтесь придерживаться этого соглашения.

Параметр  **kwargs пишется в самом конце, после последнего аргумента со значением по умолчанию. При этом функция может содержать и *args и **kwargs параметры.

Рассмотрим определение функции, которая принимает все виды аргументов.

def my_func(a, b, *args, name='Gvido', age=17, **kwargs):
    print(a, b)
    print(args)
    print(name, age)
    print(kwargs)
Приведенный ниже код:

my_func(1, 2, 3, 4, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, name='Timur', age=28, job='Teacher', language='Python')
my_func(1, 2, 3, 4, job='Teacher', language='Python')
выводит (пустая строка вставлена для наглядности):

1 2
(3, 4)
Timur 28
{'job': 'Teacher', 'language': 'Python'}

1 2
()
Timur 28
{'job': 'Teacher', 'language': 'Python'}

1 2
(3, 4)
Gvido 17
{'job': 'Teacher', 'language': 'Python'}
Не нужно пугаться, в реальном коде функции редко используют все эти возможности одновременно. Но понимать, как каждая отдельная форма объявления аргументов работает, и как такие формы сочетать — очень важно.

Для лучшего понимания, поэкспериментируйте с передачей аргументов. Правила использования аргументов довольно сложно описывать, но на практике мы редко сталкиваемся с проблемами.

Передача именованных аргументов в форме словаря
Как и в случае позиционных аргументов, именованные можно передавать в функцию "пачкой" в виде словаря. Для этого нужно перед словарём поставить две звёздочки.

Рассмотрим определение функции my_func():

def my_func(**kwargs):
    print(type(kwargs))
    print(kwargs)
Приведенный ниже код:

info = {'name':'Timur', 'age':'28', 'job':'teacher'}

my_func(**info)
выводит: 

<class 'dict'>
{'name': 'Timur', 'age': '28', 'job': 'teacher'}
Рассмотрим еще один пример определения функции print_info(), распечатывающей информацию о пользователе.

def print_info(name, surname, age, city, *children, **additional_info):
    print('Имя:', name)
    print('Фамилия:', surname)
    print('Возраст:', age)
    print('Город проживания:', city)
    if len(children) > 0:
        print('Дети:', ', '.join(children))
    if len(additional_info) > 0:
        print(additional_info)
Приведенный ниже код:

children = ['Бодхи Рансом Грин', 'Ноа Шэннон Грин', 'Джорни Ривер Грин']
additional_info = {'height':163, 'job':'actress'}

print_info('Меган', 'Фокс', 34, 'Ок-Ридж', *children, **additional_info)
выводит:

Имя: Меган
Фамилия: Фокс
Возраст: 34
Город проживания: Ок-Ридж
Дети: Бодхи Рансом Грин, Ноа Шэннон Грин, Джорни Ривер Грин
{'height': 163, 'job': 'actress'}
При подстановке аргументов "разворачивающиеся" наборы аргументов вроде *positional и **named можно указывать вперемешку с аргументами соответствующего типа: *positional с позиционными, а **named — с именованными. И, конечно, же, все именованные аргументы должны идти после всех позиционных!

Keyword-only аргументы
В Python 3 добавили возможность пометить именованные аргументы функции так, чтобы вызвать функцию можно было, только передав эти аргументы по именам. Такие аргументы называются keyword-only и их нельзя передать в функцию в виде позиционных.

Рассмотрим определение функции make_circle():

def make_circle(x, y, radius, *, line_width=1, fill=True):
Здесь * выступает разделителем: отделяет обычные аргументы (их можно указывать по имени и позиционно) от строго именованных.

Приведенный ниже код работает как и полагается:

make_circle(10, 20, 5)                                     # x=10, y=20, radius=5,  line_width=1, fill=True
make_circle(x=10, y=20, radius=7)                          # x=10, y=20, radius=7,  line_width=1, fill=True
make_circle(10, 20, radius=10, line_width=2, fill=False)   # x=10, y=20, radius=10, line_width=2, fill=False
make_circle(x=10, y=20, radius=17, line_width=3)           # x=10, y=20, radius=17, line_width=3, fill=True
То есть аргументы x, y и radius могут быть переданы в качестве как позиционных, так и именованных аргументов. При этом аргументы line_width и fill могут быть переданы только как именованные аргументы.

Приведенный ниже код:

make_circle(10, 20, 15, 20)
make_circle(x=10, y=20, 15, True)
make_circle(10, 20, 10, 2, False)
приводит к возникновению ошибок.

Этот пример неплохо демонстрирует подход к описанию аргументов. Первые три аргумента — координаты центра круга и радиус. Координаты центра и радиус присутствуют у круга всегда, поэтому обязательны и их можно не именовать. А вот line_width и fill — необязательные аргументы, ещё и получающие ничего не говорящие значения. Вполне логично ожидать, что вызов вида make_circle(10, 20, 5, 3, False) мало кому понравится! Ради ясности аргументы line_width и fill  и объявлены так, что могут быть указаны только явно через имя.

Мы также можем объявить функцию, у которой будут только строго именованные аргументы, для этого нужно поставить звёздочку в самом начале перечня аргументов.

def make_circle(*, x, y, radius, line_width=1, fill=True):
Теперь для вызова функции make_circle() нам нужно передать значения всех аргументов явно через их имя:

make_circle(x=10, y=20, radius=15)                              # line_width=1, fill=True
make_circle(x=10, y=20, radius=15, line_width=4, fill=False)
Такой разделитель можно использовать только один раз в определении функции. Его нельзя применять в функциях с неограниченным количеством позиционных аргументов *args.

Примечания.
Примечание 1. Специальный синтаксис *args и **kwargs в определении функции позволяет передавать функции переменное количество позиционных и именованных аргументов. При этом args и kwargs просто имена. Вы не обязаны их использовать, можно выбрать любые, однако среди Python программистов приняты именно эти.

Примечание 2. Вы можете использовать одновременно *args и **kwargs в одной строке для вызова функции. В этом случае порядок имеет значение. Как и аргументы, не являющиеся аргументами по умолчанию, *args должны предшествовать и аргументам по умолчанию, и **kwargs. Правильный порядок параметров:

позиционные аргументы,
*args аргументы, 
**kwargs аргументы.
def my_func(a, b, *args, **kwargs):
